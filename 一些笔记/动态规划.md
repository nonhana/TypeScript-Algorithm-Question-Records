- 重叠子问题、最优子结构、状态转移方程是动态规划三要素。

- **明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 `dp` 数组/函数的含义**。

  ```python
  # 自顶向下递归的动态规划
  def dp(状态1, 状态2, ...):
      for 选择 in 所有可能的选择:
          # 此时的状态已经因为做了选择而改变
          result = 求最值(result, dp(状态1, 状态2, ...))
      return result
  
  # 自底向上迭代的动态规划
  # 初始化 base case
  dp[0][0][...] = base case
  # 进行状态转移
  for 状态1 in 状态1的所有取值：
      for 状态2 in 状态2的所有取值：
          for ...
              dp[状态1][状态2][...] = 求最值(选择1，选择2...)
  ```

- **递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间**。
- 既然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。
- 凑零钱问题，为什么说它符合最优子结构呢？假设你有面值为 `1, 2, 5` 的硬币，你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10, 9, 6` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 `1, 2, 5` 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。