# KMP 算法

KMP（Knuth-Morris-Pratt）算法是一种用于解决字符串匹配问题的算法。字符串匹配问题可以描述为：给定一个文本字符串 `text` 和一个模式字符串 `pattern`，找出 `pattern` 在 `text` 中所有出现的位置。

传统的字符串匹配算法（如暴力匹配）的时间复杂度是 _O_(_nm_)，其中 _n_ 是文本字符串的长度，_m_ 是模式字符串的长度。KMP 算法通过预处理模式字符串来提高匹配速度，使得时间复杂度降低到 _O_(_n_+_m_)。

## 工作原理

KMP 算法的核心思想是：当某个字符不匹配时，算法能够跳过一部分文本字符，而不是逐个检查，从而提高了匹配效率。

为了实现这一点，KMP 算法预先计算一个被称为 "next 数组" 的数据结构。这个数组用于存储模式字符串中每个前缀的最长相同前缀和后缀的长度。

## 算法步骤

1. **预处理阶段**：计算模式字符串的 "next 数组"。
2. **匹配阶段**：使用 "next 数组" 来进行字符串匹配。

### 预处理阶段

1. 初始化 `next` 数组，`next[0] = -1`。
2. 遍历模式字符串，根据其前缀和后缀的相似性来填充 `next` 数组。

### 匹配阶段

1. 初始化两个指针，一个用于文本字符串（记作 `i`），一个用于模式字符串（记作 `j`）。
2. 遍历文本字符串：
   - 如果 `text[i] == pattern[j]`，则 `i++` 和 `j++`。
   - 如果 `j` 达到模式字符串的末尾，说明找到了一个匹配。然后 `j` 重置为 `next[j]`。
   - 如果 `text[i] != pattern[j]`，则 `j = next[j]`。如果 `j` 为 `-1`，则 `i++` 和 `j++`。

通过这种方式，KMP 算法能够在不回溯文本字符串的情况下，找到所有模式字符串在文本字符串中的出现位置。这大大提高了字符串匹配的效率。
